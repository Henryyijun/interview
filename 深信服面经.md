# 深信服面经

## 一面，2022-9-24

1. `C++` 继承，多态，封装
- 封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。
- 继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。
- 多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。

2. 内存泄漏
- 并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。
- 常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。
- 使用 `malloc`、`calloc`、`realloc`、`new` 等分配内存时，使用完后要调用相应的 `free` 或 `delete` 释放内存，否则这块内存就会造成内存泄漏。

3. 数组和链表的区别
- 数组是内存连续分配的数据结构
- 链表是内存离散的数据结构，通过指针连接起来。
- 数组可以随机访问，时间复杂度为`O(1)`，而链表无法随机访问，时间复杂度为`O(n)`。
- 数组插入和删除时间复杂度较高，需要涉及内存搬迁，而链表插入和删除的时间复杂度均为`O(1)`。

4. 常用的排序算法：
- 冒泡排序，稳定排序
- 插入排序，稳定排序
- 归并排序，稳定排序
- 基数排序，稳定排序
- 希尔排序，不稳定排序
- 快速排序，不稳定排序
- 选择排序，不稳定排序
- 堆排序，不稳定排序

5. 虚函数
- 实现机制：虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数
- 虚函数表相关知识点：

    - 虚函数表存放的内容：类的虚函数的地址。
    - 虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。
    - 虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。

6. 手撕代码

- [反转每对括号间的子串](https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/)

```C++
class Solution {
public:
    string reverseParentheses(string s) {
        stack<string> chars;
        string res;
        for (auto &c : s) {
           if (c == '(') {
               chars.push(res);
               res = "";
           } else if (c == ')') {
               reverse(res.begin(), res.end());
               res = chars.top() + res;
               chars.pop();
           } else {
               res.push_back(c);
           }
        }
        return res;
    }
};

```


## 二面，2022-9-29

1. 聊项目

2. 聊下了解的计算机基础知识
- 操作系统
- 计算网络

3. 智力题
- 64匹马，8个赛道，跑多少场可以跑出前四名

4. 手撕代码
- 给定一个字符串，删除字符串首尾的空格，若字符串中间存在多个空格，则只保留一个空格，例如 `"  abc  aa cc "` -> `"abc aa cc"`

```C++
class Solution {
public:
    string solution(string& str) {
        int i = 0, n = str.size(), j = n - 1;
        while (i < n && str[i] == ' ') {
            i++;
        }
        while (j >= 0 && str[j] == ' ') {
            j--;
        }

        string res = "";
        for (int k = i; k <= j; k++) {
            if (res.empty() || res.back() != ' ') {
                res += str[k];
            } else if (!res.empty() && res.back() == ' ') {
                if (str[k] == ' ') {
                    continue;
                } else {
                    res += str[k];
                }
            }
        }
        return res;
    }
}
```






